# Requirements Traceability Matrix

## Story: 1.1 - Coordinator Utilities

### Coverage Summary

- Total Requirements: 5
- Fully Covered: 5 (100%)
- Partially Covered: 0 (0%)
- Not Covered: 0 (0%)

### Requirement Mappings

#### AC1: `executeToolCall` delegates to sequential logic and preserves normalization

- **Coverage:** FULL
- **Mappings:**
  - Test File: `src/LLMProviders/chainRunner/utils/toolExecution.test.ts`
    - Test Case: `executeToolCall returns ToolResult with status ok on success`
      - Given: Coordinator receives a foreground tool call backed by existing sequential path
      - When: The wrapper executes the call through `executeSequentialToolCall`
      - Then: The result payload and status mirror the sequential outcome with no behavioural drift
      - Coverage Level: unit (Scenario `1.1-UNIT-001`)
  - Test File: `src/LLMProviders/chainRunner/utils/toolExecution.test.ts`
    - Test Case: `executeToolCall bubbles sequential errors with status error`
      - Given: Sequential execution raises an error
      - When: The coordinator wrapper resolves the promise
      - Then: The wrapper returns `status: "error"` with normalized message, maintaining downstream compatibility
      - Coverage Level: unit (Scenario `1.1-UNIT-002`)

#### AC2: `executeToolCallsInParallel` enforces concurrency cap and options

- **Coverage:** FULL
- **Mappings:**
  - Test File: `src/LLMProviders/chainRunner/utils/toolExecution.test.ts`
    - Test Case: `preserves input ordering with staggered resolution`
      - Given: Three tool calls with mixed completion latency and default concurrency
      - When: The scheduler runs with clamp logic
      - Then: Tasks start within the cap, and launches refill as slots free while results remain index-aligned
      - Coverage Level: unit (Scenario `1.1-UNIT-003` + `1.1-INT-001`)
  - Test File: `src/LLMProviders/chainRunner/utils/toolExecution.test.ts`
    - Test Case: `clamps concurrency and handles abort`
      - Given: Concurrency option below minimum with an abort signal tripped mid-flight
      - When: The pump evaluates queue capacity
      - Then: The scheduler clamps to 1, stops launching new work on abort, and respects options payload
      - Coverage Level: unit (Scenario `1.1-UNIT-003`)

#### AC3: Scheduler preserves ordering and emits hook lifecycle events

- **Coverage:** FULL
- **Mappings:**
  - Test File: `src/LLMProviders/chainRunner/utils/toolExecution.test.ts`
    - Test Case: `preserves input ordering with staggered resolution`
      - Given: Hooks spies for `onStart` and `onSettle`
      - When: Calls finish out of order
      - Then: Hooks fire per index and final array matches input ordering
      - Coverage Level: unit/integration (Scenarios `1.1-UNIT-004`, `1.1-INT-002`)

#### AC4: Abort, timeout, and error cases reuse sequential handling

- **Coverage:** FULL
- **Mappings:**
  - Test File: `src/LLMProviders/chainRunner/utils/toolExecution.test.ts`
    - Test Case: `executeToolCall bubbles sequential errors with status error`
      - Given: Sequential path throws
      - When: Wrapper resolves
      - Then: Error propagates with same normalization and status mapping
      - Coverage Level: unit (Scenario `1.1-UNIT-006`)
  - Test File: `src/LLMProviders/chainRunner/utils/toolExecution.test.ts`
    - Test Case: `executeToolCall marks timeout as timeout status`
      - Given: Deferred promise exceeding timeout
      - When: Timeout triggers
      - Then: Wrapper returns `status: "timeout"`
      - Coverage Level: unit (Scenario `1.1-UNIT-006`)
  - Test File: `src/LLMProviders/chainRunner/utils/toolExecution.test.ts`
    - Test Case: `clamps concurrency and handles abort`
      - Given: Abort signal triggered while tasks in flight
      - When: Pump processes abort
      - Then: Outstanding tasks resolve to `cancelled` without firing settle hooks
      - Coverage Level: unit (Scenario `1.1-UNIT-005`)

#### AC5: Unit tests cover ordering, error, timeout, abort, and cap boundaries

- **Coverage:** FULL
- **Mappings:**
  - Test File: `src/LLMProviders/chainRunner/utils/toolExecution.test.ts`
    - Test Case: `preserves input ordering with staggered resolution`
      - Given: Deferred promises with staggered resolve order
      - When: Fake timers advance
      - Then: Ordering and hook assertions verify deterministic behaviour
      - Coverage Level: unit (Scenario `1.1-UNIT-004`)
  - Test File: `src/LLMProviders/chainRunner/utils/toolExecution.test.ts`
    - Test Case: `executeToolCall marks timeout as timeout status`
      - Coverage Level: unit (Scenario `1.1-UNIT-005`)
  - Test File: `src/LLMProviders/chainRunner/utils/toolExecution.test.ts`
    - Test Case: `clamps concurrency and handles abort`
      - Coverage Level: unit (Scenario `1.1-UNIT-005`)
  - Test File: `src/LLMProviders/chainRunner/__tests__/parallelCoordinator.e2e.test.ts`
    - Test Case: `matches sequential aggregation for mixed-latency tool calls`
      - Given: Mixed foreground/background tools executed via coordinator harness with feature flag enabled
      - When: Parallel scheduler completes asynchronous calls out of order
      - Then: Aggregated results match sequential execution and background markers remain suppressed, satisfying E2E harness requirement
      - Coverage Level: e2e (Scenario `1.1-E2E-001`)

### Critical Gaps

- None – all acceptance criteria have full automated coverage in unit-level suites.

### Test Design Recommendations

- Maintain deterministic fake timer helpers (`flushMicrotasks`, `waitForCallCount`) when expanding integration coverage to runners in subsequent stories.
- Consider adding integration verification within runner-focused stories to observe hook behavior against actual marker pipelines once coordinator is wired in.

### Risk Assessment

- **High Risk:** None – no uncovered requirements.
- **Medium Risk:** None – no partial coverage identified.
- **Low Risk:** All ACs validated by deterministic unit coverage with supporting integration semantics in future stories.

Trace matrix: qa.qaLocation/assessments/1.1-coordinator-utilities-trace-20250928.md
